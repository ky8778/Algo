# 기초 자료 구조

### 자료구조란?

> 프로그램이 자료를 저장하는 방식
>
> 왜 이런 저런 용어들을 만들고 구조를 만들까?
>
> 추상화와 최적화를 위해



### 추상화란?

> 현실 세계에 존재하는 개념이나 구조를 간결화해 컴퓨터 프로그램에 사용되는 자료 구조로 표현하는 과정
>
> 자료구조가 어떻게 구현되는지에 대해서는 전혀 신경 쓸 필요가 없다.
>
> 내부적으로 연결리스트를 사용하는지, 배열을 사용하는지 등에 신경쓰지 않고 이와 같이 구체적인 자료와 알고리즘의 집합을 '자료구조'라는 하나의 단어로 호칭함으로써, 프로그래머는 좀더 높은 단계에서 생각할 수 있게 된다.



### 최적화란?

> 프로그램의 동작 속도를 빠르게 하기 위한 것
>
> 같은 작업을 수행하는 간단한 자료구조보다 좀더 빠른 시간 안에 작업을 할 수 있다.
>
> 실제 존재하는 자료를 잘 정리해서 저장하는 것만이 아니라 이들에 대한 작업을 더 빠르게 하기 위해 존재한다.
>
> 간단한 형태의 자료구조보다 복잡하지만, 더 빠른 시간에 같은 일을 처리할 수 있다.
>
> 탐색 자료구조들은 단순히 자료를 어떤 방식으로 표현할까에 대해서만 정의하는 것이 아니라 이 자료들을 다루는 방법, 즉 알고리즘을 같이 정의한다.



## 1. 비트마스크

현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현한다.

정수의 이진수 표현을 자료 구조로 쓰는 기법을 `비트마스크`라고 부른다.



### 비트마스크의 장점

- 더 빠른 수행 시간
- 더 간결한 코드
- 더 적은 메모리 사용량
- 연관 배열을 배열로 대체



### 비트 연산자

| 연산                             | 코드 |
| -------------------------------- | ---- |
| 두 정수 a,b를 비트별로 AND 연산  | a&b  |
| 두 정수 a,b를 비트별로 OR 연산   | a\|b |
| 두 정수 a,b를 비트별로 XOR 연산  | a^b  |
| 정수 a의 비트별 NOT 연산         | ~a   |
| 정수 a를 왼쪽으로 b비트 시프트   | a<<b |
| 정수 a를 오른쪽으로 b비트 시프트 | a>>b |



### 유의할 점

연산자 간 우선순위를 혼동할 수 있다.

이 경우 원하지 않는 답을 얻게 될 수도 있다.

실수하지 않기 위해 비트마스크를 사용하는 식에는 가능한 한 괄호를 자세하게 추가하는 습관을 들이는 것이 좋다.



### 비트마스크를 이용한 집합의 구현

N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 된다.

```c++
// 공집합과 꽉 찬 집합 구하기
int full = (1<<20) - 1;

// 원소 추가
mySet |= (1<<p);						// 더하기를 하게 되면 값이 없는 경우 문제가 발생한다.

// 원소의 포함 여부 확인
if(mySet & (1<<p)) cout << "p is in" << endl;
if((mySet & (1<<p)) == 1) cout << "p is in" << endl;		// 이와 같이 하게 될 경우 다른 값이 된다. 해당 조건식의 결과는 1이 아니라 2의 p-1제곱이다.

// 원소의 삭제
mySet -= (1<<p);						// 빼기를 하게 되면 값이 없는 경우 문제가 발생한다.
mySet &= ~(1<<p);

// 원소의 토글
mySet ^= (1<<p);						// p번 원소가 들어가 있는 경우 빼고, 빠져 있는 경우 넣는 코드가 된다.

// 두 집합에 대해 연산하기
int added = (a|b);					// a와 b의 합집합
int intersection = (a&b);		// a와 b의 교집합
int removed = (a & ~b);			// a에서 b를 뺀 차집합
int toggled = (a ^ b);			// a와 b중 하나에만 포함된 원소들의 집합

// 집합의 크기 구하기
int bitCount(int x){
  if(x==0) return 0;
  return x%2 + bitCount(x/2);
}

// 최소 원소 찾기
int firstVal = (mySet & ~mySet);		// 음수가 two's complement 로 구현되기 때문에 가능하다.

// 최소 원소 지우기
mySet &= (mySet-1);

// 모든 부분 집합 순회하기
for(int subset = mySet; subset; subset = ((subset-1)&mySet)){
  // subset은 mySet의 부분집합
}

```



## 2. 부분 합

부분합 혹은 누적합이란?

> 배열의 각 위치에 대해 배열의 시작부터 현재 위치까지의 원소의 합을 구해 둔 배열이다.
>
> psum[i] = scores[0] + scores[1] + ... + scores[i]

psum을 미리 계산해 두면 scores[]의 특정 구간의 합을 O(1)에 구할 수 있다.



### 부분 합 계산하기

구간 합을 빠르게 계산하기 위해서는 부분 합을 미리 계산해 둘 필요가 있다.

반복문을 통해 구간 합을 구하기 위해 최대 O(N)의 시간이 걸리기 때문에, 구간 합을 두번 이상 구할 때는 대부분의 경우 부분 합을 사용하는 쪽이 이득이다.



### 부분 합으로 분산 계산하기

부분 합을 이용해서 합 혹은 평균 외에도 다른 값들을 쉽게 계산할 수 있는데, 그 중 한 가지가 특정 구간의 분산(Variance)이다.

> 분산 = (값-평균)의 제곱의 합
>
> v = (Σ(A[]-m)^2) / (b-a+1)
>
> = (ΣA[]^2 - 2\*m\*ΣA[] + (b-a+1)\*m^2) / (b-a+1)
>
> 인데 괄호안의 세 항 중, 가운데 항과 오른쪽 항은 psum을 이용해 쉽게 계산할 수 있다.
>
> 제곱의 부분합도 저장해둔 다면 왼쪽항 또한 O(1)에 계산할 수 있다.



### 2차원으로의 확장

A[a,b] 에서 A[c,d]까지의 직사각형 구간의 합을 계산해야 하는 경우도 2차원 부분 합을 이용해서 빠르게 구해낼 수 있다.



## 3. 선형 자료 구조

일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조는 배열이다.

배열처럼 일렬로 늘어선 자료들을 저장하기 위한 다른 자료 구조로 `동적 배열`과 `연결 리스트`가 있다.

동적 배열과 연결 리스트의 가장 큰 차이점은 삽입 / 삭제 그리고 임의의 원소에 접근하는 데 드는 시간이다.

삽입과 삭제를 할 일이 없거나, 배열의 끝에서만 하면 될 경우에는 동적 배열이 거의 항상 더 좋은 선택이다.

임의의 원소에 빠르게 접근할 수 있으며, 원소들이 메모리에 연속해 배치되어 있기 때문에 CPU 캐시의 효율도 더 높여준다.

임의의 원소에 접근하는 것이 아니라, 모든 원소들을 순회하며 삽입과 삭제를 한다면 연결 리스트가 좋은 선택이다.



### 동적 배열

배열의 큰 문제 중 하나는 처음 선언할 때 배열의 크기를 지정해야하며, 그 이상의 자료를 저장할 수 없다는 점이다.

동적 배열은 내부적으로 배열을 이용하기 때문에 배열의 특성을 이어받는다.

- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.

배열과 다른 특성도 갖는다.

- 배열의 크기를 변경하는 resize() 연산이 가능하다. 배열의 크기 N에 비례하는 시간복잡도를 갖는다.
- 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append() 연산이 가능하다. 상수 시간복잡도를 갖는다.



#### 구현방식

> 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 둔다.
>
> 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮긴다.
>
> 미리 할당받은 메모리의 크기를 배열의 용량(capacity), 실제 원소의 수를 배열의 크기(size)라 한다.
>
> append() 연산이 상수시간에 가능하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사해서 다음 배열에 대한 포인터를 바꿔치기 하는 과정이 효율적이어야 한다.
>
> 다양한 방식이 있겠지만 상수시간에 가능하게 구현하기 위해서는 재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.
>
> 동적 배열 사용 시 팁은, append() 연산을 여러 번 수행할 때 배열의 최종 크기가 어느정도인지 미리 짐작할 수 있다면, 동적 배열의 용량을 미리 늘려두어 재할당에 드는 비용을 없애는 것이 효율적이다.



### 연결 리스트

배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 임의의 위치에서 원소를 삭제하는 것은 시간이 오래걸린다.

해당 위치 뒤에 있는 원소들을 하나씩 뒤칸 혹은 앞칸으로 옮겨야 하기 때문이다. 평균적으로 원소의 개수에 선형 비례하는 시간이 걸린다.

연결 리스트는 특정 위치에서 삽입과 삭제를 상수 시간에 할 수 있게 해준다.

배열과는 달리 연결 리스트에서는 메모리 여기저기에 노드들이 흩어져 있기 때문에 특정 위치의 값을 찾기가 쉽지 않다.

결과적으로 i번째 노드를 찾는 데 드는 시간은 리스트의 길이에 선형 비례하게 된다.

특정 위치에 노드를 삽입/삭제하는 과정은 연결리스트에서 포인터만 변경해주면 되기 때문에 각각 상수 시간에 이루어진다.











