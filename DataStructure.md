# 기초 자료 구조

자료구조란?

> 프로그램이 자료를 저장하는 방식
>
> 왜 이런 저런 용어들을 만들고 구조를 만들까?
>
> 추상화와 최적화를 위해



추상화란?

> 현실 세계에 존재하는 개념이나 구조를 간결화해 컴퓨터 프로그램에 사용되는 자료 구조로 표현하는 과정
>
> 자료구조가 어떻게 구현되는지에 대해서는 전혀 신경 쓸 필요가 없다.
>
> 내부적으로 연결리스트를 사용하는지, 배열을 사용하는지 등에 신경쓰지 않고 이와 같이 구체적인 자료와 알고리즘의 집합을 '자료구조'라는 하나의 단어로 호칭함으로써, 프로그래머는 좀더 높은 단계에서 생각할 수 있게 된다.



최적화란?

> 프로그램의 동작 속도를 빠르게 하기 위한 것
>
> 같은 작업을 수행하는 간단한 자료구조보다 좀더 빠른 시간 안에 작업을 할 수 있다.
>
> 실제 존재하는 자료를 잘 정리해서 저장하는 것만이 아니라 이들에 대한 작업을 더 빠르게 하기 위해 존재한다.
>
> 간단한 형태의 자료구조보다 복잡하지만, 더 빠른 시간에 같은 일을 처리할 수 있다.
>
> 탐색 자료구조들은 단순히 자료를 어떤 방식으로 표현할까에 대해서만 정의하는 것이 아니라 이 자료들을 다루는 방법, 즉 알고리즘을 같이 정의한다.



## 비트마스크

현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현한다.

정수의 이진수 표현을 자료 구조로 쓰는 기법을 `비트마스크`라고 부른다.



#### 비트마스크의 장점

- 더 빠른 수행 시간
- 더 간결한 코드
- 더 적은 메모리 사용량
- 연관 배열을 배열로 대체



### 비트 연산자

| 연산                             | 코드 |
| -------------------------------- | ---- |
| 두 정수 a,b를 비트별로 AND 연산  | a&b  |
| 두 정수 a,b를 비트별로 OR 연산   | a\|b |
| 두 정수 a,b를 비트별로 XOR 연산  | a^b  |
| 정수 a의 비트별 NOT 연산         | ~a   |
| 정수 a를 왼쪽으로 b비트 시프트   | a<<b |
| 정수 a를 오른쪽으로 b비트 시프트 | a>>b |



#### 유의할 점

연산자 간 우선순위를 혼동할 수 있다.

이 경우 원하지 않는 답을 얻게 될 수도 있다.

실수하지 않기 위해 비트마스크를 사용하는 식에는 가능한 한 괄호를 자세하게 추가하는 습관을 들이는 것이 좋다.



#### 비트마스크를 이용한 집합의 구현

N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 된다.

```c++
// 공집합과 꽉 찬 집합 구하기
int full = (1<<20) - 1;

// 원소 추가
mySet |= (1<<p);						// 더하기를 하게 되면 값이 없는 경우 문제가 발생한다.

// 원소의 포함 여부 확인
if(mySet & (1<<p)) cout << "p is in" << endl;
if((mySet & (1<<p)) == 1) cout << "p is in" << endl;		// 이와 같이 하게 될 경우 다른 값이 된다. 해당 조건식의 결과는 1이 아니라 2의 p-1제곱이다.

// 원소의 삭제
mySet -= (1<<p);						// 빼기를 하게 되면 값이 없는 경우 문제가 발생한다.
mySet &= ~(1<<p);

// 원소의 토글
mySet ^= (1<<p);						// p번 원소가 들어가 있는 경우 빼고, 빠져 있는 경우 넣는 코드가 된다.

// 두 집합에 대해 연산하기
int added = (a|b);					// a와 b의 합집합
int intersection = (a&b);		// a와 b의 교집합
int removed = (a & ~b);			// a에서 b를 뺀 차집합
int toggled = (a ^ b);			// a와 b중 하나에만 포함된 원소들의 집합

// 집합의 크기 구하기
int bitCount(int x){
  if(x==0) return 0;
  return x%2 + bitCount(x/2);
}

// 최소 원소 찾기
int firstVal = (mySet & ~mySet);		// 음수가 two's complement 로 구현되기 때문에 가능하다.

// 최소 원소 지우기
mySet &= (mySet-1);

// 모든 부분 집합 순회하기
for(int subset = mySet; subset; subset = ((subset-1)&mySet)){
  // subset은 mySet의 부분집합
}

```



## 부분 합

부분합 혹은 누적합이란?

> 배열의 각 위치에 대해 배열의 시작부터 현재 위치까지의 원소의 합을 구해 둔 배열이다.
>
> psum[i] = scores[0] + scores[1] + ... + scores[i]

psum을 미리 계산해 두면 scores[]의 특정 구간의 합을 O(1)에 구할 수 있다.



### 부분 합 계산하기

구간 합을 빠르게 계산하기 위해서는 부분 합을 미리 계산해 둘 필요가 있다.

반복문을 통해 구간 합을 구하기 위해 최대 O(N)의 시간이 걸리기 때문에, 구간 합을 두번 이상 구할 때는 대부분의 경우 부분 합을 사용하는 쪽이 이득이다.



### 부분 합으로 분산 계산하기

부분 합을 이용해서 합 혹은 평균 외에도 다른 값들을 쉽게 계산할 수 있는데, 그 중 한 가지가 특정 구간의 분산(Variance)이다.

> 분산 = (값-평균)의 제곱의 합
>
> v = (Σ(A[]-m)^2) / (b-a+1)
>
> = (ΣA[]^2 - 2\*m\*ΣA[] + (b-a+1)\*m^2) / (b-a+1)
>
> 인데 괄호안의 세 항 중, 가운데 항과 오른쪽 항은 psum을 이용해 쉽게 계산할 수 있다.
>
> 제곱의 부분합도 저장해둔 다면 왼쪽항 또한 O(1)에 계산할 수 있다.



### 2차원으로의 확장

A[a,b] 에서 A[c,d]까지의 직사각형 구간의 합을 계산해야 하는 경우도 2차원 부분 합을 이용해서 빠르게 구해낼 수 있다.









